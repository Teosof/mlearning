# Лекция №13. Алгоритм Кендалла

## Описание алгоритма

Пусть существует матрица “объект-свойство” $X$, размером $M\times N$ и вектор классификации $C$ размером $M$.

$C[I]=1$, если $I$-ый объект $X[I:]$ принадлежит классу $1$.

$C[I]=2$, если $I$-ый объект $X[I:]$ принадлежит классу $2$.

### Обучение

1. Для всех признаков $x_i, i=1, 2, …, N$ необходимо определить пороги “чистого сечения” $p_1,p_2$ такие, что

   $x\leqslant p_1$ - $x$ принадлежит одному классу;

   $x\geqslant p_2$ - $x$ принадлежит другому классу

2. Отсортировать признаки по информативности — числу точек в области пересечения
3. Сохранить результаты

### Классификация

Если значение первого признака попадает в “чистую” область, то требуется выдать результат и прекратить выполнение
алгоритма, иначе перейти к следующему признаку и повторить классификацию. Если все признаки перебраны выдать результат
“неизвестный класс” и прекратить выполнение алгоритма.

## Функции

Число точек в области пересечения множеств (выборок). Аргументы $a, b$ - выборки значений признака (векторы) для классов
$1,2$. Результат $n$ - число точек в области пересечения.

```apl
	∇ n←a cross b 
[1] n←+/b<⌈/a25
[2] n←n⌊+/b>⌊/a25 ⍝ сколько b>min a 
[3] ∇
```

Пример:

```apl
	1 2 3 cross 2.1 2.9 4 5
2
```

## Правило для одного признака

Аргументы $a, b$ - выборки значений признака (векторы) для классов $1,2$. Результат $r$ - вектор четырех элементов:

1. порог (меньше или равно) - класс для этого порога
2. порог (больше или равно) - класс для этого порога

```apl
   ∇ r←a rule b;c;ab ⍝ множество значений признака для b (b;c;ab) [1] c←∊(⍴ ̈a b)⍴ ̈1 2
[2] c←c[⍋a,b]
[3] ab←(a,b)[⍋a,b]
[4] r←(⌈/(∧\c=↑c)/ab),↑c
[5] r←r,(⌊/(⌽∧\(  ̄1↑c)=⌽c)/ab), ̄1↑c [6] ∇
```

Пример:

```apl
   (1 2 3)(9 4 8) rules (2.1 2.9 4 5)(3 4.5 1 2) 
2 3 2 8 1 1 2 1 4 2
   disp (1 2 3)(9 4 8) rules (2.1 2.9 4 5)(3 4.5 1 2) 
.→------------------------.
| .→--------. .→--------. |
| |2 3 2 8 1| |1 2 1 4 2| |
| '~--------' '~--------' |
'∊------------------------'
```

Слева: $x<3$ - класс 2; $x>8$ - класс 1 Справа: $x<2$ - класс 1; $x>4$ - класс 2

## Классификация по одному правилу

1. Правый аргумент $x$ — точка подлежащая классификации
2. Левый аргумент $r$ — правило в формате функции rule
3. Результат — номер класса

```apl
   ∇ c←r class x 
[1] c←0
[2] ⍎(x≤r[1])/'c←r[2]' 
[3] ⍎(x≥r[3])/'c←r[4]' 
[4] ∇
```

Пример:

```apl
   2 1 4 2 class 0 
1
   2 1 4 2 class 5 
2
   2 1 4 2 class 3 ⍝ do not know 
0
```

## Диагностирование (классификация по всем правилам)

1. Аргумент (правый) $x$ — точка подлежащая классификации
2. Аргумент (левый) $rules$ — все правила в формате функции $rules$
3. Результат — номер класса

```apl
   ∇ d←rules diag x;i;r 
   [1] i←1
[2] L:r←i⊃rules
[3] d←(1↓r)class x[↑r] 
[4] →(d≠0)/0
[5] →((⍴rules)≤i←i+1)/L 
[6] ∇
```

Пример с ирисами:

```apl
ir1: 50x4 matrix of class 1 of Iris
ir2: 50x4 matrix of class 2 of Iris
ir3: 50x4 matrix of class 3 of Iris
```

Пример правил для двух классов:

```apl
   rr←(⊂[1]ir1) rules ⊂[1]ir2
   disp rr 
.→------------------------------------------------------------. 
| .→----------. .→----------. .→------------. .→------------. | 
| |3 1.9 1 3 2| |4 0.6 1 1 2| |1 4.9 1 5.8 2| |2 2.2 2 3.5 1| | 
| '~----------' '~----------' '~------------' '~------------' | 
'∊------------------------------------------------------------'
```

Проверка точности классификации:

```apl
   +d←(⊂rr) diag ̈ ⊂[2]ir1 
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
   d∧.=1 
1
   100×(+/d=1)÷⍴d
100
   d←(⊂rr) diag ̈ ⊂[2]ir2
   100×(+/d=2)÷⍴d 
100
```

**Признаки** - спектральные амплитуды на заданных частотах.