# Лекция №8. Метод Сэммона

Пусть существует в $n$-мерном пространстве набор точек векторов  $\overrightarrow{x_1},\overrightarrow{x_2},...,\overrightarrow{x_n}$.  На плоскости будет существовать набор точек вектора, который задан $\overrightarrow{y_1},\overrightarrow{y_2},...,\overrightarrow{y_n}$. 

Для каждой пары точек $i$ и $j$ в исходном $n$-мерном пространстве мы можем посчитать расстояние между ними:
$$
d_{ij}=\|\overrightarrow{x_i}-\overrightarrow{x_j}\|=\sqrt{\sum^N_{k=1}(x_{ik}-x_{jk}})^2
$$

$$
\overrightarrow{x_i}=\begin{bmatrix}
    x_{1i} \\
    x_{2i} \\
    ... \\
    x_{ni} \\
\end{bmatrix},
\overrightarrow{x_j}=\begin{bmatrix}
    x_{1j} \\
    x_{2j} \\
    ... \\
    x_{nj} \\
\end{bmatrix}
$$

Аналогичные рассуждения и для двухмерного пространства (расстояние между $y$).
$$
d^*_{ij}=\|\overrightarrow{y_i}-\overrightarrow{y_j}\|=\sqrt{\sum^2_{k=1}(y_{ik}-y_{jk})^2}
$$


## Описание метода

Мы должны расположить точки на плоскости таким образом, чтобы взаимные расстояния между $i$ и $j$ максимально соответствовали расстоянию в исходном пространстве. Критерием этого является:
$$
\xi=(\sum^N_{i<j}d_{ij})^{-1}\frac{\sum^N_{i<j}(d_{ij}-d^*_{ij})^2{}}{d_{ij}}
$$
Обратим внимание на разность расстояний и расстояние на плоскости в квадрате. Матрица расстояний является симметричной. 
$$
D_{ij}=\begin{bmatrix}
    0 & d_{12} & ... & ... & ... \\
    d_{21} & 0 & ... & ... & ... \\
    ... & ... & 0 & ... & ... \\
    ... & ... & ... & 0 & d_{ji} \\
    ... & ... & ... & d_{ji} & 0 \\
\end{bmatrix}
$$

$$
d_{12}=d_{21}
$$

Не имеет смысла сравнивать равные расстояния, поэтому из матрицы используется только верхний (нижний) треугольник. Таким образом, мы должны оптимизировать квадраты разностей между расстояниями и в исходном пространстве, и на плоскости. 

Определим значение для $d_{ij}^{-1}$. Данный множитель делает разности относительными. Если в исходном пространстве $d_{ij}$ большое, то и сама разность будет большой. Некий нормировочный множитель:
$$
(\sum^N_{i<j}d_{ij})^{-1}
$$
Для минимизации самого критерия, нужно минимизировать множитель. Таким образом, $d_{ij}$ является фиксированным, а $d^*_{ij}$ может быть изменен. Если какие-то $i, j$ точки оказались близки между собой, а в исходном пространстве были расположен далеко, то мы можем выполнить операцию по перемещению этих объектов. 

Расстояния $\overrightarrow{y}$ появляются случайно на плоскости $N$. 

```apl
[0] z←{y}sam x;e;i;j;k;dx;dy;m;a;c;l
[1] a←0.35  ⍝ [.3,.4] Sammon told
[2] ⍎(0=⎕NC'y')/'y←⍉mds.Orloci x' 
[3] dx←dist x
[4] m←,m°.<m←⍳↑⍴dx 
[5] dy←dist y
[6] e←⍬
[7] L:e,←(÷+/m/,dx)×+/(m/,(dx-dy)*2)÷m/,dx
[8] :For i :In ⍳↑⍴y
[9] l←i≠⍳↑⍴y 
[10] c←(l⌿(y[i;]-[2]y)×[1]dx[i;]-dy[i;])÷[1]l/dx[i;]×dy[i;]
[11] y[i;]←y[i;]+(2×a÷+/m/,dx)×+⌿c 
[12] :EndFor 
[13] dy←dist y 
[14] →(1000>⍴e)/L
[15] z←e y
```

Правый аргумент от $sam$ - вектор $n$-мерных векторов, левый аргумент в фигурных скобках означает опциональность. Если он существует, то мы помещаем на плоскости эти $N$ точек. Если он отсутствует, то в качестве левого приближения используются проекции на оси Орлочи. 

Рассмотрим пример в трёхмерном пространстве. Для определённости представим, что длина ребра равна единице. 

```apl
      ⍴xy ⍝ вершины этих кубиков
8 3
      xy ⍝ матрица из координат вершин
0 0 0
1 0 0
0 1 0
0 0 1
0 1 1
1 0 1
1 1 0
1 1 1
      (⍳8) plotc ⊂[2]Orloci xy ⍝ спроектируем её с помощью Орлочи
```

![График](/Users/roman/PycharmProjects/machine_learning/lections/images/lection8/1.png)

Выделяем каждую точку своим маркером и цветом. При линейном проектировании некоторые точки совпали, что является не удовлетворительным результатом. Расстояние между любой парой вершин должно быть не меньше единицы, но на данном графике мы получаем, что между какими-то вершинами расстояние ноль. Воспользуемся методом Сэммона:

```apl
      z←sam xy
      (⍳8) plotc ⊂[1]2⊃z
```

![График](/Users/roman/PycharmProjects/machine_learning/lections/images/lection8/2.png)

В результат каждая из восьми точек на совсем месте. Так выглядит куб при проектировании на плоскость. 

Представим, что в каждой вершине находится несколько точек, которая соответствуем каждому из восьми классов:

```apl
      xy1←⊂[2]xy
      xy2←xy1{⍺,[1]⍺+[2]⍵}¨⊂[2 3]8 5 3⍴0 0.1 stat.rndn×/8 5 3
      ⍴xy2←,[1 2]⊃xy2
48 3
      (∊6⍴¨⍳8) plotc ⊂[2]mds.Orloci xy2
```

![График](/Users/roman/PycharmProjects/machine_learning/lections/images/lection8/3.png)

В результате вновь происходит наложение маркеров друг на друга. Спроектируем их на оси Сэммона:

```apl
      z2←(?48 2⍴100)sam xy2
      plot 200↑↓z2 ⍝ как меняется критерий ξ при оптимизации
```

![График](/Users/roman/PycharmProjects/machine_learning/lections/images/lection8/4.png)


```apl
      (∊6⍴¨⍳8) plotc ⊂[1]2⊃z2
```

![График](/Users/roman/PycharmProjects/machine_learning/lections/images/lection8/5.png)

В полученных результатах все классы расположены на некоторой дистанции друг от друга. Используем метод распознавания (метод эталонов — среднее по всем точкам, которые принадлежат данному классу). Это позволит нам распознать центры каждого класса. Данный метод позволяет определить к какому из классов относится точка: считаем расстояние от неизвестной точки до центра эталона. Класс, у которого это расстояние будет минимальным, является владельцем этой точки. 

Рассмотри метод Сэммона на Rlang:

```R
> xy2<-read.table("d:/xy2.txt") 
> xy2<-as.matrix(xy2)
> s2<-sammon(dist(xy2)) 
Initial stress : 0.08900 
stress after 10 iters: 0.05915, magic = 0.500 
stress after 20 iters: 0.05881, magic = 0.500 
stress after 30 iters: 0.05871, magic = 0.500 
stress after 40 iters: 0.05864, magic = 0.500 
> plot(s2$points,type="n") 
> text(s2$points,labels=as.character(1:nrow(xy2)))
```

​					  ![График](/Users/roman/PycharmProjects/machine_learning/lections/images/lection8/6.png)

```R
> plot(s2$points,type="p")
```

![График](/Users/roman/PycharmProjects/machine_learning/lections/images/lection8/7.png)

Выполним аналогичные операции на APL, но будем выполнять эти действия некий определенный срок.

```apl
	⍴s ⍝ взяли в качестве начального приближения какой-то пятимерный массив
47 5
	z←(?47 2⍴100)sam s ⍝ запустили его с Сэммоном, взяв в качестве приближения случайные 47 точек на плоскости
	z←(2⊃z)sam s sam[9]
⍴e 894678
    ee←e
⍴y 47 2
    yy←y plot ee ⍝ видим, что за выбранное нами время прошли 894678 итераций
```

![График](/Users/roman/PycharmProjects/machine_learning/lections/images/lection8/8.png)

Отобразим проекции:

```apl
    0 plot ⊂[1]yy
```

![График](/Users/roman/PycharmProjects/machine_learning/lections/images/lection8/9.png)

Долгое время выполнения операций объясняет тем, что APL - интерпретируемый язык. 

Однако, R также является язык интерпретатором, но он быстрый, так как низкоуровневые функции написан на языке С, следовательно, при обработке данных происходит не интерпретация, а вызов метода. В APL реализована связь с R:


```apl
      )copy rconnect
      r←⎕new R   ⍝создаем новый объект
      r.init     ⍝инициализируем
RConnect initialized
```

Внутри R представлены следующие функции:

```apl
      'x' r.p ⍳9      ⍝помещает в R какой-то объект из APL, левый аргумент – под каким именем я его буду помещать, а правый аргумент – что за объект
      +r.g 'x'        ⍝взять из R какой-то объект
1 2 3 4 5 6 7 8 9
      +r.x 'sum(x)'   ⍝в качестве аргумента берет вызов какой-то R-ой функции каким-то аргументом. Например, X – которые засланы в R просуммируем там же
45
      +/⍳9            ⍝проверили не наврал ли R
45 
```

```apl
⍝ generate 3 clusters data for sammon prejections
      x1←?30 50⍴0
      x2←2+?30 50⍴0
      x3←¯2+?30 50⍴0
      ⍴xx←x1⍪x2⍪x3
90 50
      r.x'library(MASS)'
      r.x'ss<-sammon(dist(⍵))'xx
      r.x'ss<-plot(ss$points)'
      pp←r.g'ss$points'
      pp
[R matrix: 90x2 : dimnames]
      p1←r.x'p1<-pp[,1]'
      p2←r.x'p2<-pp[,2]'
      ]load plt
#.plt
      plt.plot p1 p2
      r.x'ss<-plot(ss$points)'
      'x2'r.p x2
      pp←r.x 'ss$points'
      'xx' r.p xx
      r.x'ss<-sammon(dist(xx))'
      r.x 'plot(ss$points)'
      ⎕←pp←r.x 'ss$points'
[R matrix: 90x2 : dimnames]
       ⎕←r.x 'summary(ss$points)'
 [R table - 6 rows]                        
        V1                    V2           
  Min.   :-16.994313    Min.   :-3.5412    
  1st Qu.:-13.543887    1st Qu.:-1.1105    
  Median :  0.006133    Median :-0.1200    
  Mean   :  0.000000    Mean   : 0.0000    
  3rd Qu.: 13.483473    3rd Qu.: 0.9875    
  Max.   : 16.769582    Max.   : 6.5274    
       pp←r.x 'ss$points'
      ⍴pp.Value ⍝ what I forgot it was get Value from a complex object pp
90 2
      +⌿pp.Value
¯2.675637489E¯14 ¯4.218847494E¯15
      ⌈⌿pp.Value
16.76958233 6.527426142
      ⌊⌿pp.Value
¯16.99431306 ¯3.54116532
      plt.plot pp.Value
```
